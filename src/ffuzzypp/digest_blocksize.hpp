/*

	ffuzzy++ : C++ implementation of fast fuzzy hashing

	digest_blocksize.hpp
	Fuzzy digest block size utilities


	CREDITS OF ORIGINAL VERSION OF SSDEEP

	Copyright (C) 2002 Andrew Tridgell <tridge@samba.org>
	Copyright (C) 2006 ManTech International Corporation
	Copyright (C) 2013 Helmut Grohne <helmut@subdivi.de>

	This program is free software; you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation; either version 2 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA


	CREDIT OF MODIFIED PORTIONS

	Copyright (C) 2015 Tsukasa OI <floss_ssdeep@irq.a4lg.com>

*/
#ifndef FFUZZYPP_DIGEST_BLOCKSIZE_HPP
#define FFUZZYPP_DIGEST_BLOCKSIZE_HPP

#include <cassert>
#include <cstddef>
#include <cstdint>

#include <limits>

#include "utils/safe_int.hpp"
#include "utils/static_assert_query.hpp"
#include "utils/numeric_digits.hpp"

namespace ffuzzy {

// Block size type for fuzzy digest
typedef uint_least32_t digest_blocksize_t;

// Block size utilities
class digest_blocksize
{
	static_assert(
		safe_int::contracts::is_unsigned_integral_type<digest_blocksize_t>() &&
		std::numeric_limits<digest_blocksize_t>::max() >= 0xfffffffful,
		"digest_blocksize_t must be an unsigned integral type which can represent all 32-bit values."
	);
private:
	digest_blocksize(void) = delete;
	digest_blocksize(const digest_blocksize&) = delete;

	// Parameters
public:
	static constexpr const unsigned number_of_blockhashes = 31;
	static constexpr const digest_blocksize_t min_blocksize = 3;
	static constexpr const digest_blocksize_t max_blocksize = min_blocksize << (number_of_blockhashes - 1);
	static_assert(min_blocksize != 0, "min_blocksize must not be zero.");
	static_assert(number_of_blockhashes != 0, "number_of_blockhashes must not be zero.");
	static_assert(number_of_blockhashes <= 32, "number_of_blockhashes must be less than 32.");
	static_assert(min_blocksize <= 0xfffffffful, "min_blocksize must be less than 2^32.");
	static_assert(
		safe_int::safe_lshift<
			safe_int::uvalue<digest_blocksize_t, min_blocksize>,
			safe_int::uvalue<unsigned, number_of_blockhashes - 1>
		>::is_valid &&
		(min_blocksize << (number_of_blockhashes - 1)) <= 0xfffffffful,
		"(min_blocksize << (number_of_blockhashes - 1)) must be less than 2^32.");

	// Maximum characters required to represent all "natural" block sizes
	// (excluding '\0' character at the end)
public:
	static constexpr const size_t max_natural_digits =
		numeric_digits::in_decimal(max_blocksize);

	// Block size naturality
	// (whether this is possibly generated by ssdeep)
public:
	static bool is_natural(digest_blocksize_t blocksize) noexcept
	{
		if (blocksize < min_blocksize)
			return false;
		if (blocksize > max_blocksize)
			return false;
		while (blocksize != min_blocksize)
		{
			if (blocksize % 2 != 0)
				return false;
			blocksize /= 2;
		}
		return true;
	}

	// Utility to prevent arithmetic overflow
public:
	static constexpr bool is_safe_to_double(digest_blocksize_t value) noexcept
	{
		return value <= (std::numeric_limits<digest_blocksize_t>::max() / 2);
	}

	/*
		"Near" relations

		fuzzy digests are compared against other if their block sizes are "near".
		There are three such cases (if there is no arithmetic overflow).

		Case 1: a == b (eq)
			Digest A : 3:xxxxxxx:yyyyyyy
			Digest A : 3:xxxxxxx:yyyyyyy
			|            ~~~~~~~ ~~~~~~~
			|            (both block hashes are compared and the maximum score is chosen)
		Case 2: a * 2 == b (implies a < b; lt)
			Digest A : 3:xxxxxxx:yyyyyyy
			Digest B : 6:        yyyyyyy:zzzzzzz
			|                    ~~~~~~~
			|            (block hash in common block size is compared)
		Case 3: a == b * 2 (implies a > b; gt)
			Digest A : 6:        yyyyyyy:zzzzzzz
			Digest B : 3:xxxxxxx:yyyyyyy
			|                    ~~~~~~~
			|            (block hash in common block size is compared)
	*/
public:
	static constexpr bool is_near_eq(digest_blocksize_t a, digest_blocksize_t b) noexcept
	{
		return a == b;
	}
	static constexpr bool is_near_lt(digest_blocksize_t a, digest_blocksize_t b) noexcept
	{
		return a != b && is_safe_to_double(a) && a * 2 == b;
	}
	static constexpr bool is_near_gt(digest_blocksize_t a, digest_blocksize_t b) noexcept
	{
		return a != b && a % 2 == 0 && a / 2 == b;
	}
	static constexpr bool is_near_leq(digest_blocksize_t a, digest_blocksize_t b) noexcept
	{
		return is_near_eq(a, b) || is_near_lt(a, b);
	}
	static constexpr bool is_near(digest_blocksize_t a, digest_blocksize_t b) noexcept
	{
		return is_near_eq(a, b) || is_near_lt(a, b) || is_near_gt(a, b);
	}

	// Utility to convert block size index to a natural block size
public:
	static constexpr digest_blocksize_t at(unsigned index) noexcept
	{
		return min_blocksize << index;
	}

	// Utility to convert natural block size to corresponding block size index
private:
	template <bool UseMagic, typename Tdummy = void> class natural_to_index_impl;
	// Implementation by magic table
	// (not general [depends on ssdeep parameters] but possibly fast)
	static constexpr const digest_blocksize_t nti_magic_mul = digest_blocksize_t(0x017713caul);
	static constexpr const unsigned nti_magic_table[31] =
	{
		0x00, 0x01, 0x02, 0x06, 0x03, 0x0b, 0x07, 0x10,
		0x04, 0x0e, 0x0c, 0x18, 0x08, 0x15, 0x11, 0x1a,
		0x1e, 0x05, 0x0a, 0x0f, 0x0d, 0x17, 0x14, 0x19,
		0x1d, 0x09, 0x16, 0x13, 0x1c, 0x12, 0x1b,
	};
	template <typename Tdummy>
	class natural_to_index_impl<true, Tdummy>
	{
	public:
		static constexpr unsigned natural_to_index_unsafe(digest_blocksize_t blocksize) noexcept
		{
			return nti_magic_table[((blocksize * nti_magic_mul) >> 27) & 0x1f];
		}
	private:
		#ifdef FFUZZYPP_STATIC_SANITY_CHECKS
		template <uintmax_t i>
		struct seq_check
		{
			static constexpr const bool value =
				natural_to_index_unsafe(min_blocksize << i) == i;
		};
		static_assert(static_assert_query::is_all<seq_check, number_of_blockhashes>::value,
			"magic table is not constructed correctly.");
		#endif
	};
	// Implementation by De Brujin sequence
	// (general but requires a division to make index_from work)
	static constexpr const digest_blocksize_t nti_debrujin_mul = digest_blocksize_t(0x077cb531ul);
	static constexpr const unsigned nti_debrujin_table[32] =
	{
		0x00, 0x01, 0x1c, 0x02, 0x1d, 0x0e, 0x18, 0x03,
		0x1e, 0x16, 0x14, 0x0f, 0x19, 0x11, 0x04, 0x08,
		0x1f, 0x1b, 0x0d, 0x17, 0x15, 0x13, 0x10, 0x07,
		0x1a, 0x0c, 0x12, 0x06, 0x0b, 0x05, 0x0a, 0x09,
	};
	template <typename Tdummy>
	class natural_to_index_impl<false, Tdummy>
	{
	public:
		static constexpr unsigned natural_to_index_unsafe(digest_blocksize_t blocksize) noexcept
		{
			return nti_debrujin_table[((blocksize / min_blocksize * nti_debrujin_mul) >> 27) & 0x1f];
		}
	private:
		#ifdef FFUZZYPP_STATIC_SANITY_CHECKS
		template <uintmax_t i>
		struct seq_check
		{
			static constexpr const bool value =
				natural_to_index_unsafe(min_blocksize << i) == i;
		};
		static_assert(static_assert_query::is_all<seq_check, number_of_blockhashes>::value,
			"De Brujin sequence is not constructed correctly.");
		#endif
	};
	static constexpr const bool nti_is_magic_available =
		min_blocksize == 3 && number_of_blockhashes <= 31;
public:
	template <bool UseDebrujin = false>
	static constexpr unsigned natural_to_index_unsafe(digest_blocksize_t blocksize) noexcept
	{
		return natural_to_index_impl<
			nti_is_magic_available && !UseDebrujin
		>::natural_to_index_unsafe(blocksize);
	}
	template <bool UseDebrujin = false>
	static unsigned natural_to_index(digest_blocksize_t blocksize) noexcept
	{
		#ifdef FFUZZYPP_DEBUG
		assert(is_natural(blocksize));
		#endif
		return natural_to_index_unsafe<UseDebrujin>(blocksize);
	}
};


#ifdef FFUZZYPP_DECLARATIONS
constexpr const unsigned digest_blocksize::nti_magic_table[31];
constexpr const unsigned digest_blocksize::nti_debrujin_table[32];
#endif

}

#endif
